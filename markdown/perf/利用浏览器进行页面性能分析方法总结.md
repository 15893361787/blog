### 背景
性能优化是所有前端人的追求，在这条路上，方法多种多样。这篇文章，说一下利用浏览器可以怎样进行性能分析，主要包括自主打点上报、浏览器工具分析等方面。

### 自定义关键性能时间点
#### 统计方法
`window.performance` 是W3C性能小组引入的 API,截止目前，其支持度已经很高了，支持性如下：
<!-- //贴图 -->
`window.performance.timing`里面有很多的性能相关的时间戳记录，我们来看一些常用的：

|    属性    | 含义 |
| ---------- | --- |
| navigationStart |  准备加载页面的起始时间 |
| domainLookupStart       |  开始进行dns查询的时间 |
| domainLookupEnd | dns查询结束的时间|
| connectStart | TCP连接开始 |
| connectEnd | TCP连接完成 | 
| domInteractive | 解析dom树开始 |
| domComplete | 解析dom树结束 |
| loadEventEnd | onload事件结束的时间 |
| fetchStart | 开始检查缓存或开始获取资源的时间 |
| domLoading | loading的时间 (这个时候还木有开始解析文档)|
更多查看：https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming

#### 关键指标
这样，我们就可以定出一些关键步骤耗时：
```doc
DNS查询耗时 = domainLookupEnd - domainLookupStart
TCP链接耗时 = connectEnd - connectStart
request请求耗时 = responseEnd - responseStart
解析dom树耗时 = domComplete - domInteractive
白屏时间 = domloading - fetchStart
domready时间 = domContentLoadedEventEnd - fetchStart
onload时间 = loadEventEnd - fetchStart
```
这个数据，上报到系统。就可以看到页面的情况如何，然后进行对应的优化了。不过，实际情况中，前端更关注的性能指标在首屏，比如：
+ HTML 加载完成时间
+ 首屏图片加载完成时间
+ 首屏接口完成加载完成时间
+ FP(首次绘制时间)
+ FCP(首次内容渲染时间)

#### window.performance.timing 实现
这个时候，我们可以自己手动加上一些点，结合一起上报。比如：
```js
//window.loadHtmlTime 在html中的</body>标签前端打个时间戳即可
HTMLComplete = window.loadHtmlTime - window.performance.timing.navigationStart

//window.lastImgLoadTime 在首屏中的每张图onload之后都更新一次这个时间戳
firstScreenImgFinished = window.lastImgLoadTime - window.performance.timing.navigationStart

//Report.SPEED.MAINCGI 在首屏中的每个接口调用成功后更新时间戳
firstScreenApiFinished = Report.SPEED.MAINCGI - window.performance.timing.navigationStart

//在所有接口打时间点
apiFinishes = Report.SPEED.LASTCGI - window.performance.timing.navigationStart);
```
注意：我们在做性能埋点的时候，最好不要入侵业务代码。这里我的想法是，每个api调用的方法，我们都返回一个Promise，这样，我们再另外封装一个sdk去找到这些方法，然后分别注册then方法来计时即可。
#### window.performance.getEntries() 实现
window.performance.getEntries方法调用后可以获取所有资源请求的时间数据。