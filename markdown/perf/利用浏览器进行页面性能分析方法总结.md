### 背景
性能优化是所有前端人的追求，在这条路上，方法多种多样。这篇文章，说一下利用浏览器可以怎样进行性能分析，主要包括自主打点上报、浏览器工具分析等方面。

### 自定义性能指标上报
自定义性能指标这里，主要要介绍的是 `Performance 接口`,这个接口可以获取到当前页面中与性能相关的信息。主要包含了Performance Timeline API、Navigation Timing API、 User Timing API 和 Resource Timing API。

`Performance`类型的对象可以通过调用只读属性 Window.performance 来获得,截止目前，其支持度已经很高了，支持性如下：
<!-- //贴图 -->

#### window.performance.navigation
`window.performance.navigation` 对象提供了在指定的时间段里发生的操作相关信息，包括页面是加载还是刷新、发生了多少次重定向等。我们可以看看：

|    属性    | 含义 |
| ---------- | --- |
| type |  表示是如何导航到这个页面的 |
| redirectCount        |  表示在到达这个页面之前重定向了多少次 |

其中，type 的取值及含义如下表：

|    type的值    | 含义 |
| ---------- | --- |
| 0 |  当前页面是通过点击链接，书签和表单提交，或者脚本操作，或者在url中直接输入地址 |
| 1 |  点击刷新页面按钮或者通过Location.reload()方法显示的页面 |
| 2 |  页面通过历史记录和前进后退访问时 |
| 255 |  任何其他方式 |
具体数据示例：
<!-- 图 -->
这个数据，主要是帮助我们看看页面重定向次数是否过多(能否减少重定向)，页面访问的方式主要是怎样的，针对访问方式较多的场景我们能否做些优化。

这种情况下，我们只需要把数据直接上报，然后自己查看数据的时候，再跟具体含义结合起来理解即可。

#### window.performance.timing
`window.performance.timing`里面有很多的性能相关的时间戳记录，我们来看一些常用的：

|    属性    | 含义 |
| ---------- | --- |
| navigationStart |  准备加载页面的起始时间 |
| domainLookupStart       |  开始进行dns查询的时间 |
| domainLookupEnd | dns查询结束的时间|
| connectStart | TCP连接开始 |
| connectEnd | TCP连接完成 | 
| domInteractive | 解析dom树开始 |
| domComplete | 解析dom树结束 |
| loadEventEnd | onload事件结束的时间 |
| fetchStart | 开始检查缓存或开始获取资源的时间 |
| domLoading | loading的时间 (这个时候还木有开始解析文档)|

更多查看：https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming

##### 关键指标
这样，我们就可以定出一些关键步骤耗时：
```doc
DNS查询耗时 = domainLookupEnd - domainLookupStart
TCP链接耗时 = connectEnd - connectStart
request请求耗时 = responseEnd - responseStart
解析dom树耗时 = domComplete - domInteractive
白屏时间 = domloading - fetchStart
domready时间 = domContentLoadedEventEnd - fetchStart
onload时间 = loadEventEnd - fetchStart
```
这个数据，上报到数据平台系统。就可以看到页面的性能情况如何，然后进行对应的优化了。不过，实际情况中，前端更关注的性能指标在首屏，比如：
+ HTML 加载完成时间
+ 首屏图片加载完成时间
+ 首屏接口完成加载完成时间

这个时候，我们可以自己手动加上一些点，结合一起上报。代码示例如下：

```js
//window.loadHtmlTime 在html中的</body>标签前端打个时间戳即可
HTMLComplete = window.loadHtmlTime - window.performance.timing.navigationStart

//window.lastImgLoadTime 在首屏中的每张图onload之后都更新一次这个时间戳
firstScreenImgFinished = window.lastImgLoadTime - window.performance.timing.navigationStart

//Report.SPEED.MAINCGI 在首屏中的每个接口调用成功后更新时间戳
firstScreenApiFinished = Report.SPEED.MAINCGI - window.performance.timing.navigationStart

//在所有接口打时间点
apiFinishes = Report.SPEED.LASTCGI - window.performance.timing.navigationStart);
```
注意：我们在做性能埋点的时候，最好不要入侵业务代码。这里我的想法是，每个api调用的方法，我们都返回一个Promise，这样，我们再另外封装一个sdk去找到这些方法，然后分别注册then方法来计时即可。

#### window.performance.getEntries
`window.performance.getEntries` 方法调用后可以获取所有资源请求的时间数据。

+ FP(首次绘制时间)
+ FCP(首次内容渲染时间)